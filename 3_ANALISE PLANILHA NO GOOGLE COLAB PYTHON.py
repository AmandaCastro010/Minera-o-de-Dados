# -*- coding: utf-8 -*-
"""yt-sentiment_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15jtFEsGNXWaia9zBCbgXFRG9Yhwms_kt

Importa as bibliotecas necess√°rias
"""

import pandas as pd
from transformers import AutoTokenizer, AutoModelForSequenceClassification, pipeline
from google.colab import files
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

"""Recebe o arquivo CSV"""

uploaded = files.upload()

"""Abre o CSV"""

df = pd.read_csv("sheets_comentarios-bert.csv")
df.head()

model_name = "nlptown/bert-base-multilingual-uncased-sentiment"
tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModelForSequenceClassification.from_pretrained(model_name)


sentiment_pipeline = pipeline("sentiment-analysis", model=model, tokenizer=tokenizer)

comentarios = df["Coment√°rio"].astype(str).tolist()
resultados = sentiment_pipeline(comentarios)

def converter_estrelas(label):
    score = int(label.split()[0])
    if score <= 2:
        return "negativo"
    elif score == 3:
        return "neutro"
    else:
        return "positivo"

# Aplicar ao DataFrame
df["BERT Estrelas"] = [r["label"] for r in resultados]
df["Sentimento BERT"] = df["BERT Estrelas"].apply(converter_estrelas)

df.to_csv("comentarios_com_sentimento_bert.csv", index=False)

files.download("comentarios_com_sentimento_bert.csv")

df = pd.read_csv("comentarios_com_sentimento_bert.csv")

df["Likes"] = pd.to_numeric(df["Likes"], errors="coerce").fillna(0)

# (recarregue seu DataFrame se necess√°rio)
resumo = df.groupby("Sentimento BERT")["Likes"].sum().reset_index()

plt.figure(figsize=(8, 5))
ax = sns.barplot(data=resumo, x="Sentimento BERT", y="Likes", palette="Set2")
plt.title("Engajamento por Sentimento (modelo BERT)")
plt.xlabel("")
plt.ylabel("Likes acumulados")

# Adiciona os valores acima de cada barra
for p in ax.patches:
    ax.annotate(f'{int(p.get_height())}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='bottom', fontsize=11)

plt.tight_layout()
plt.show()

contagem = df["Sentimento BERT"].value_counts().reset_index()
contagem.columns = ["Sentimento", "Qtd de Coment√°rios"]

plt.figure(figsize=(8, 5))
ax = sns.barplot(data=contagem, x="Sentimento", y="Qtd de Coment√°rios", palette="Blues")
plt.title("Distribui√ß√£o de Coment√°rios por Sentimento (BERT)")
plt.xlabel("")
plt.ylabel("Qtd de Coment√°rios")

for p in ax.patches:
    ax.annotate(f'{int(p.get_height())}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='bottom', fontsize=11)

plt.tight_layout()
plt.show()

# Ordenar os coment√°rios por n√∫mero de likes (do maior para o menor)
top_10 = df.sort_values(by="Likes", ascending=False).head(10).reset_index(drop=True)

# Exibir de forma leg√≠vel
print("üî• TOP 10 COMENT√ÅRIOS MAIS CURTIDOS\n" + "="*60)
for i, row in top_10.iterrows():
    print(f"\n#{i+1} | üë§ {row['Autor']} | üëç {row['Likes']} | üß† Sentimento: {row['Sentimento BERT']}")
    print(f"üó®Ô∏è  {row['Coment√°rio']}")
    print("-" * 60)